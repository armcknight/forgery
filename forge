#!/usr/bin/env python3

from github import Github
import argh
from argh import arg
import os
import requests
import shutil
import subprocess

_organization = 'organization'
_user = 'user'

_public_subpath = 'public'
_private_subpath = 'private'
_forked_subpath = 'forked'
_starred_subpath = 'starred'

_repos_subpath = 'repos'
_gists_subpath = 'gists'

def _clone_repo(ssh_url, clone_path):
    'Clone a repo to a path and return True, or skip and return False if it already exists there.'
    if not os.path.exists(clone_path):
        subprocess.check_call(['git', 'clone', ssh_url, clone_path])
        return True
    else:
        print(f'{ssh_url} already cloned')
        return False

def _clone_wiki(repo, clone_path):
    'Clone the wiki associated with a repo, or skip if it already exists locally.'
    if repo.has_wiki:
        wiki_url = f'git@github.com:{repo.full_name}.wiki.git'
        p = subprocess.Popen(['git', 'ls-remote', '-h', wiki_url], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        p.communicate()
        if p.returncode == 0:
            wiki_path = f'{clone_path}.wiki'
            if not os.path.exists(wiki_path):
                subprocess.check_call(['git', 'clone', wiki_url, wiki_path])
            else:
                print(f'{wiki_url} already cloned')

def _tag_repo(repo, clone_path):
    'Set tags on the local repo directory with the language and topics from the GitHub repo, if present.'
    topics = repo.get_topics()
    if (topics is None or len(topics) == 0) and repo.language is None:
        return
    if topics is not None and len(topics) > 0:
        taglist = [topic.lower() for topic in topics]
    else:
        taglist = []
    if repo.language is not None:
        taglist.append(repo.language.lower())
    subprocess.check_call(['tag', '-a', ','.join({tag for tag in taglist}), clone_path])

def _clone_nonforked_repo(repo, repo_type_path, no_wikis):
    'Clone a normal repo and any associated wiki.'
    clone_path = f'{repo_type_path}/{repo.name}'
    if _clone_repo(repo.ssh_url, clone_path):
        _tag_repo(repo, clone_path)
    if not no_wikis:
        _clone_wiki(repo, clone_path)

def _gist_ssh_url(gist):
    'Because gist entries from the GitHub API don\'t include an SSH url for cloning (but that does work in practice) this function takes the HTTPS address, pulls apart the necessary info, and reformulates it into an SSH Git URL.'
    gist_path = gist.git_pull_url.replace('https://gist.github.com/', '')
    return f'git@gist.github.com:{gist_path}'

def _is_kind_of_repo_to_sync(x, gist, repo, public, private, forked, starred):
    'Determine if the repo passed in as `x` should be synced based on its properties and the provided options.'
    if gist:
        return (
            x.name == repo.description
            and (
                (public and x.public)
                or (private and not x.public)
                or (forked and x.fork_of is not None)
            )
        )
    else:
        return (
            x.name == repo.name
            and (
                starred
                or (public and not x.private)
                or (private and x.private)
                or (forked and x.fork)
            )
        )

def _update_local_repos_under(path, remote_repo_list, push_to_fork_remotes, prune, public=False, private=False, forked=False, gist=False, starred=False):
    'Given a path to a local repo and list of remote repositories, fetch and fast-forward commits from upstream. If it\'s a fork, optionally push to the remote downstream fork. If the local repo is no longer in the list of remote repos, optionally prune it by deleting the local clone.'
    if not os.path.exists(path):
        return
    for repo in os.scandir(path):
        repos_to_sync = [x for x in remote_repo_list if _is_kind_of_repo_to_sync(x, gist, repo, public, private, forked, starred)]
        repo_to_sync = next(iter(repos_to_sync), None)
        if repo_to_sync is not None:
            if forked:
                remote_name = 'upstream'
            else:
                remote_name = 'origin'
            print(f'syncing {repo.path}')
            subprocess.check_call(f'git fetch {remote_name} && git pull --ff-only {remote_name}', shell=True, cwd=repo.path)
            if push_to_fork_remotes:
                subprocess.check_call(['git', 'push', remote_name], cwd=repo.path)
            _tag_repo(repo_to_sync, repo.path)
        elif prune:
            print(f'pruning {repo.path}')
            shutil.rmtree(repo.path)

@arg('access_token', help='The GitHub access token of the GitHub user whose repos should be synced')
@arg('base_path', help='Location of the repos to sync')
@arg('--push_to_fork_remotes', help='After fast-forwarding any new commits from forks\' remote upstreams, push the new commitsto fork remotes.', default=False)
@arg('--prune', help='If a local repository is no longer listed from the server, remove its local clone.')
def sync(access_token, base_path, push_to_fork_remotes=False, prune=False):
    'Sync repos that have been previously cloned for all local users and organizations, by fetching and fast-forwarding to pick up any new commits. Update the tags associated with cloned repos, as those may change over time. Will only be able to work with private repos for the user authenticated with the provided access token; other users\' will only have public repos updated, so this will need to be run once for each user whose private and starred repos/gists should be synced, using their access tokens in turn.'
    g = Github(access_token)
    authenticated_user = g.get_user()
    for account_type in os.scandir(base_path):
        if account_type.name == '.DS_Store':
            continue
        if account_type.name == _user:
            user_dir = f'{base_path}/{_user}'
            for user in os.scandir(user_dir):
                if user.name == '.DS_Store':
                    continue
                account = g.get_user(user.name)
                remote_repos = account.get_repos()
                remote_gists = account.get_gists()
                user_repos_path = f'{user_dir}/{user.name}/{_repos_subpath}'
                user_gists_path = f'{user_dir}/{user.name}/{_gists_subpath}'
                _update_local_repos_under(f'{user_repos_path}/{_public_subpath}', remote_repos, push_to_fork_remotes, prune, public=True)
                _update_local_repos_under(f'{user_gists_path}/{_public_subpath}', remote_gists, push_to_fork_remotes, prune, public=True, gist=True)
                for forked_repo in os.scandir(f'{user_repos_path}/{_forked_subpath}'):
                    _update_local_repos_under(forked_repo.path, remote_repos, push_to_fork_remotes, prune, forked=True)
                for forked_gist in os.scandir(f'{user_gists_path}/{_forked_subpath}'):
                    _update_local_repos_under(forked_gist.path, remote_gists, push_to_fork_remotes, prune, forked=True, gist=True)
                if authenticated_user == user.name:
                    remote_starred_repos = account.get_starred()
                    remote_starred_gists = account.get_starred_gists()
                    _update_local_repos_under(f'{user_repos_path}/{_private_subpath}', remote_repos, push_to_fork_remotes, prune, private=True)
                    _update_local_repos_under(f'{user_gists_path}/{_private_subpath}', remote_gists, push_to_fork_remotes, prune, private=True, gist=True)
                    for starred_repo in os.scandir(f'{user_repos_path}/{_starred_subpath}'):
                        _update_local_repos_under(starred_repo.path, remote_starred_repos, push_to_fork_remotes, prune, starred=True)
                    for starred_gist in os.scandir(f'{user_gists_path}/{_starred_subpath}'):
                        _update_local_repos_under(starred_gist.path, remote_starred_gists, push_to_fork_remotes, prune, gist=True, starred=True)
        elif account_type.name == _organization:
            for org in os.scandir(f'{base_path}/{_organization}'):
                if org.name == '.DS_Store':
                    continue
                account = g.get_organization(org.name)
                remote_repos = account.get_repos()
                remote_public_gists = account.public_gists
                remote_private_gists = account.private_gists
                org_repos_path = f'{org.path}/{_repos_subpath}'
                org_gists_path = f'{org.path}/{_gists_subpath}'
                _update_local_repos_under(f'{org_repos_path}/{_public_subpath}', remote_repos, push_to_fork_remotes, prune, public=True)
                _update_local_repos_under(f'{org_gists_path}/{_public_subpath}', remote_public_gists, push_to_fork_remotes, prune, public=True, gist=True)
                for forked_repo in os.scandir(f'{org_repos_path}/{_forked_subpath}'):
                    _update_local_repos_under(forked_repo.path, remote_repos, push_to_fork_remotes, prune, forked=True)
                _update_local_repos_under(f'{org_repos_path}/{_private_subpath}', remote_repos, push_to_fork_remotes, prune, private=True)
                _update_local_repos_under(f'{org_gists_path}/{_private_subpath}', remote_private_gists, push_to_fork_remotes, prune, private=True, gist=True)
        else:
            print(f'unexpected account type directory: {account_type}; expected either `{_user}` or `{_organization}`')

@arg('access_token', help='The GitHub access token of the GitHub user whose repos should be synced')
@arg('base_path', help='Location of the repos to sync')
@arg('--no_public_repos', help='Do not clone the authenticated user\'s or organization\'s public repos', default=False)
@arg('--no_private_repos', help='Do not clone the authenticated user\'s or organization\'s private repos', default=False)
@arg('--no_starred_repos', help='Do not clone the authenticated user\'s or organization\'s starred repos (does not apply to organizations)', default=False)
@arg('--no_forked_repos', help='Do not clone the authenticated user\'s or organization\'s forked repos', default=False)
@arg('--no_public_gists', help='Do not clone the authenticated user\'s or organization\'s public gists', default=False)
@arg('--no_private_gists', help='Do not clone the authenticated user\'s or organization\'s private gists', default=False)
@arg('--no_starred_gists', help='Do not clone the authenticated user\'s starred gists (does not apply to organizations)', default=False)
@arg('--no_forked_gists', help='Do not clone the authenticated user\'s forked gists (does not apply to organiations)', default=False)
@arg('--no_wikis', help='Do not clone wikis associated with any repos that are cloned', default=False)
@arg('--organization', help='Instead of fetching the list of the authenticated user\'s repos, fetch the specified organzation\'s. This means there will be no starred repos/gists.', default=None, type=str)
def clone(access_token, base_path, no_public_repos=False, no_private_repos=False, no_starred_repos=False, no_forked_repos=False, no_public_gists=False, no_private_gists=False, no_starred_gists=False, no_forked_gists=False, no_wikis=False, organization=None):
    'Clone the public, private, starred and forked repos and gists, as well as any associated wikis, unless disabled with options, from the specified account managed by the provided access token, or optionally from a specified organization (which won\'t have starred repos or any gists).'
    g = Github(access_token)
    if organization is not None:
        account = g.get_organization(organization)
        account_type = _organization
        repos = account.get_repos()
    else:
        account = g.get_user()
        account_type = _user
        repos = account.get_repos(affiliation='owner')
    repos_path = f'{base_path}/{account_type}/{account.login}/{_repos_subpath}'
    fork_path = f'{repos_path}/{_forked_subpath}'
    star_path = f'{repos_path}/{_starred_subpath}'
    public_path = f'{repos_path}/{_public_subpath}'
    private_path = f'{repos_path}/{_private_subpath}'
    subprocess.check_call(['mkdir', '-p', fork_path, public_path, private_path])
    if organization is None:
        subprocess.check_call(['mkdir', '-p', star_path])
    for repo in repos:
        if repo.fork:
            if no_forked_repos:
                continue
            r = g.get_repo(repo.full_name)
            clone_path = f'{fork_path}/{r.parent.owner.login}/{repo.name}'
            if _clone_repo(repo.ssh_url, clone_path):
                subprocess.check_call(['git', 'remote', 'rename', 'origin', 'fork'], cwd=clone_path)
                subprocess.check_call(['git', 'remote', 'add', 'upstream', r.parent.ssh_url], cwd=clone_path)
                default_branch = subprocess.check_output('git rev-parse --abbrev-ref fork/HEAD | cut -c6-', shell=True, encoding='utf-8', cwd=clone_path).strip()
                subprocess.check_call(['git', 'config', '--unset', f'branch.{default_branch}.remote'], cwd=clone_path)
                subprocess.check_call(['git', 'config', '--add', f'branch.{default_branch}.remote', 'upstream'], cwd=clone_path)
                subprocess.check_call(['git', 'config', '--add', f'branch.{default_branch}.pushRemote', 'fork'], cwd=clone_path)
                _tag_repo(r.parent, clone_path)
                if not no_wikis:
                    _clone_wiki(r.parent, clone_path)
        elif repo.private:
            if no_private_repos:
                continue
            _clone_nonforked_repo(repo, private_path, no_wikis)
        else:
            if no_public_repos:
                continue
            _clone_nonforked_repo(repo, public_path, no_wikis)
    if organization is None and not no_starred_repos:
        for repo in account.get_starred():
            _clone_nonforked_repo(repo, f'{star_path}/{repo.owner.login}', no_wikis)
    if organization is not None: # orgs don't have gists, so we can skip all the logic to clone them
        return
    gists_path = f'{base_path}/{account_type}/{account.login}/{_gists_subpath}'
    public_gists_path = f'{gists_path}/{_public_subpath}'
    private_gists_path = f'{gists_path}/{_private_subpath}'
    starred_gists_path = f'{gists_path}/{_starred_subpath}'
    forked_gists_path = f'{gists_path}/{_forked_subpath}'
    subprocess.check_call(['mkdir', '-p', public_gists_path, private_gists_path, starred_gists_path])
    for gist in account.get_gists():
        if not no_forked_gists and gist.fork_of is not None:
            upstream = g.get_gist(gist.fork_of.id)
            _clone_repo(_gist_ssh_url(upstream), f'{forked_gists_path}/{upstream.owner.login}/{gist.description}')
        else:
            gist_ssh_url = _gist_ssh_url(gist)
            if not no_public_gists and gist.public:
                _clone_repo(gist_ssh_url, f'{public_gists_path}/{gist.description}')
            elif not no_private_gists:
                _clone_repo(gist_ssh_url, f'{private_gists_path}/{gist.description}')
    if not no_starred_gists:
        for gist in account.get_starred_gists():
            gist_ssh_url = _gist_ssh_url(gist)
            _clone_repo(gist_ssh_url, f'{starred_gists_path}/{gist.owner.login}/{gist.description}')

parser = argh.ArghParser()
parser.add_commands([clone, sync])

if __name__ == '__main__':
    parser.dispatch()
