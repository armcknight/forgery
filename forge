#!/usr/bin/env python3

from github import Github
import argh
from argh import arg
import os
import requests
import shutil
import subprocess

_organization = 'organization'
_user = 'user'

_public_subpath = 'public'
_private_subpath = 'private'
_forked_subpath = 'forked'
_starred_subpath = 'starred'

_repos_subpath = 'repos'
_gists_subpath = 'gists'

def _clone_repo(ssh_url, clone_path):
    'Clone a repo to a path and return True, or skip and return False if it already exists there.'
    if not os.path.exists(clone_path):
        subprocess.check_call(['git', 'clone', ssh_url, clone_path])
        return True
    else:
        print(f'{ssh_url} already cloned')
        return False

def _clone_wiki(repo, clone_path):
    'Clone the wiki associated with a repo, or skip if it already exists locally.'
    if repo.has_wiki:
        wiki_url = f'git@github.com:{repo.full_name}.wiki.git'
        p = subprocess.Popen(['git', 'ls-remote', '-h', wiki_url], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        p.communicate()
        if p.returncode == 0:
            wiki_path = f'{clone_path}.wiki'
            if not os.path.exists(wiki_path):
                subprocess.check_call(['git', 'clone', wiki_url, wiki_path])
            else:
                print(f'{wiki_url} already cloned')

def _tag_repo(repo, clone_path):
    topics = repo.get_topics()
    if (topics is None or len(topics) == 0) and repo.language is None:
        return
    if topics is not None and len(topics) > 0:
        taglist = [topic.lower() for topic in topics]
    else:
        taglist = []
    if repo.language is not None:
        taglist.append(repo.language.lower())
    subprocess.check_call(['tag', '-a', ','.join({tag for tag in taglist}), clone_path])

def _clone_nonforked_repo(repo, repo_type_path, no_wikis):
    'Clone a normal repo and any associated wiki.'
    clone_path = f'{repo_type_path}/{repo.name}'
    if _clone_repo(repo.ssh_url, clone_path):
        _tag_repo(repo, clone_path)
    if not no_wikis:
        _clone_wiki(repo, clone_path)

def _gist_ssh_url(gist):
    gist_path = gist.git_pull_url.replace('https://gist.github.com/', '')
    return f'git@gist.github.com:{gist_path}'

def _update_local_repos_under(path, remote_repo_list, push_to_fork_remotes, prune, public=False, private=False, forked=False, gist=False):
    for repo in os.scandir(path):
        if len(filter(lambda x:
                        (
                            (gist and x.name == repo.description)
                            or (not gist and x.name == repo.name)
                        ) and (
                            (public and x.public)
                            or (priavte and not x.public)
                            or (forked and x.fork)
                        ),
                        remote_repo_list)) > 0:
            if forked:
                remote_name = 'upstream'
            else:
                remote_name = 'origin'
            subprocess.check_call(f'git fetch {remote_name} && git pull --ff-only {remote_name}', shell=True, cwd=repo.path)
            if push_to_fork_remotes:
                subprocess.check_call(['git', 'push', remote_name], cwd=repo.path)
        elif prune:
            print(f'pruning {repo.path}')
            shutil.rmtree(repo.path)

@arg('access_token', help='The GitHub access token of the GitHub user whose repos should be synced')
@arg('base_path', help='Location of the repos to sync')
@arg('--push_to_fork_remotes', help='After fast-forwarding any new commits from forks\' remote upstreams, push the new commitsto fork remotes.', default=False)
@arg('--prune', help='If a local repository is no longer listed from the server, remove its local clone.')
def sync(access_token, base_path, push_to_fork_remotes=False, prune=False):
    'Sync repos that have been previously cloned for all local users and organizations, by fetching and fast-forwarding to pick up any new commits. Update the tags associated with cloned repos, as those may change over time. Will only be able to work with private repos for the user authenticated with the provided access token; other users\' will only have public repos updated, so this will need to be run once for each user whose private repos should be synced, using their access tokens in turn.'
    # iterate through local repos per account/organization
    g = Github(access_token)
    for account_types in os.scandir(base_path):
        if account_type == _user:
            user_dir = f'{base_path}/{_user}'
            for user in os.scandir(user_dir):
                account = g.get_user(user)
                remote_repos = account.get_repos()
                remote_starred_repos = account.get_starred()
                remote_gists = account.get_gists()
                remote_starred_gists = account.get_starred_gists()
                _update_local_repos_under(f'{user_dir}/{_repos_subpath}/{_public_subpath}', push_to_fork_remotes, prune, remote_repos, public=True)
                _update_local_repos_under(f'{user_dir}/{_repos_subpath}/{_private_subpath}', push_to_fork_remotes, prune, remote_repos, private=True)
                _update_local_repos_under(f'{user_dir}/{_repos_subpath}/{_forked_subpath}', push_to_fork_remotes, prune, remote_repos, forked=True)
                _update_local_repos_under(f'{user_dir}/{_repos_subpath}/{_starred_subpath}', push_to_fork_remotes, prune, remote_starred_repos)
                _update_local_repos_under(f'{user_dir}/{_gists_subpath}/{_public_subpath}', push_to_fork_remotes, prune, remote_gists, public=True, gist=True)
                _update_local_repos_under(f'{user_dir}/{_gists_subpath}/{_private_subpath}', push_to_fork_remotes, prune, remote_gists, private=True, gist=True)
                _update_local_repos_under(f'{user_dir}/{_gists_subpath}/{_forked_subpath}', push_to_fork_remotes, prune, remote_gists, forked=True, gist=True)
                _update_local_repos_under(f'{user_dir}/{_gists_subpath}/{_starred_subpath}', push_to_fork_remotes, prune, remote_starred_gists, gist=True)
        # elif account_type == _organization:
        #     for user in os.scandir(f'{base_path}/{_organization}'):
        #         account = g.get_organization(organization)
        #         remote_repos = account.get_repos()
        #         remote_gists = account.get_gists()
        else:
            print(f'unexpected account type directory: {account_type}')

        # build list of locally cloned repos


        # get list of repos from GitHub


        # update tags


        # fetch/fast-forward


@arg('access_token', help='The GitHub access token of the GitHub user whose repos should be synced')
@arg('base_path', help='Location of the repos to sync')
@arg('--no_public_repos', help='Do not clone the authenticated user\'s public repos', default=False)
@arg('--no_private_repos', help='Do not clone the authenticated user\'s private repos', default=False)
@arg('--no_starred_repos', help='Do not clone the authenticated user\'s starred repos', default=False)
@arg('--no_forked_repos', help='Do not clone the authenticated user\'s forked repos', default=False)
@arg('--no_public_gists', help='Do not clone the authenticated user\'s public gists', default=False)
@arg('--no_private_gists', help='Do not clone the authenticated user\'s private gists', default=False)
@arg('--no_starred_gists', help='Do not clone the authenticated user\'s starred gists', default=False)
@arg('--no_wikis', help='Do not clone wikis associated with any repos that are cloned', default=False)
@arg('--organization', help='Instead of fetching the list of the authenticated user\'s repos, fetch the specified organzation\'s. This means there will be no starred repos/gists.', default=None, type=str)
def clone(access_token, base_path, no_public_repos=False, no_private_repos=False, no_starred_repos=False, no_forked_repos=False, no_public_gists=False, no_private_gists=False, no_starred_gists=False, no_wikis=False, organization=None):
    'Clone the public, private, starred and forked repos and gists, as well as any associated wikis, unless disabled with options, from the specified account managed by the provided access token, or optionally from a specified organization.'
    g = Github(access_token)
    if organization is not None:
        account = g.get_organization(organization)
        account_type = _organization
    else:
        account = g.get_user()
        account_type = _user
    repos_path = f'{base_path}/{account_type}/{account.login}/{_repos_subpath}'
    fork_path = f'{repos_path}/{_forked_subpath}'
    star_path = f'{repos_path}/{_starred_subpath}'
    public_path = f'{repos_path}/{_public_subpath}'
    private_path = f'{repos_path}/{_private_subpath}'
    subprocess.check_call(['mkdir', '-p', fork_path, star_path, public_path, private_path])
    for repo in account.get_repos(affiliation='owner'):
        if repo.fork:
            if no_forked_repos:
                continue
            r = g.get_repo(repo.full_name)
            clone_path = f'{fork_path}/{r.parent.owner.login}/{repo.name}'
            if _clone_repo(repo.ssh_url, clone_path):
                subprocess.check_call(['git', 'remote', 'rename', 'origin', 'fork'], cwd=clone_path)
                subprocess.check_call(['git', 'remote', 'add', 'upstream', r.parent.ssh_url], cwd=clone_path)
                _tag_repo(r.parent, clone_path)
                if not no_wikis:
                    _clone_wiki(r.parent, clone_path)
        elif repo.private:
            if no_private_repos:
                continue
            _clone_nonforked_repo(repo, private_path, no_wikis)
        else:
            if no_public_repos:
                continue
            _clone_nonforked_repo(repo, public_path, no_wikis)
    if organization is None and not no_starred_repos:
        for repo in account.get_starred():
            _clone_nonforked_repo(repo, f'{star_path}/{repo.owner.login}', no_wikis)
    gists_path = f'{base_path}/{account.login}/{_gists_subpath}'
    public_gists_path = f'{gists_path}/{_public_subpath}'
    private_gists_path = f'{gists_path}/{_private_subpath}'
    starred_gists_path = f'{gists_path}/{_starred_subpath}'
    forked_gists_path = f'{gists_path}/{_forked_subpath}'
    subprocess.check_call(['mkdir', '-p', starred_gists_path, public_gists_path, private_gists_path])
    for gist in account.get_gists():
        if gist.fork_of is not None:
            upstream = g.get_gist(gist.fork_of.id)
            _clone_repo(_gist_ssh_url(upstream), f'{forked_gists_path}/{upstream.owner.login}/{gist.description}')
        else:
            gist_ssh_url = _gist_ssh_url(gist)
            if gist.public:
                _clone_repo(gist_ssh_url, f'{public_gists_path}/{gist.description}')
            else:
                _clone_repo(gist_ssh_url, f'{private_gists_path}/{gist.description}')
    if organization is None and not no_starred_gists:
        for gist in account.get_starred_gists():
            gist_ssh_url = _gist_ssh_url(gist)
            _clone_repo(gist_ssh_url, f'{starred_gists_path}/{gist.owner.login}/{gist.description}')

parser = argh.ArghParser()
parser.add_commands([clone, sync])

if __name__ == '__main__':
    parser.dispatch()
